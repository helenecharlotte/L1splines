% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/L1spline.R
\name{L1spline}
\alias{L1spline}
\title{L1 spline.

Function to compute the L1 spline, by use of the splitting method.}
\usage{
L1spline(t, y, gfun, y0 = 0, kappa = 1, lambda = 1e-04, x = Inf,
  niter = 200, sw = NULL, t0 = NULL, CI = 0, niterk = 5,
  stopiter = 1e-10, constr = -Inf, sign = 1, mp = 100, b = 0)
}
\arguments{
\item{t}{Numeric vector of measurement times.}

\item{y}{Numeric vector of values to be fitted.}

\item{gfun}{Choice of Greens function (1-10).}

\item{y0}{Numeric value to move y-values up or down. Per default y0 = 0.}

\item{kappa}{Asymmetry parameter. Kappa is estimated if kappa=NULL is specified.
Default is kappa = 1, corresponding to no skewness.}

\item{lambda}{Smoothness parameter.}

\item{x}{Numeric vector. If specified, spline is computed in this set of points.}

\item{niter}{Number of iterations.}

\item{sw}{Integer value corresponding to number of anchor points used in sigma estimation.
Default is sw=NULL, corresponding to no sigma estimation.}

\item{t0}{Numeric vector of anchor points used in sigma estimation.
Default is t0=NULL, so that sigma estimation is only performed when sw is not NULL.
If t0 is specified, this overrules sw.}

\item{CI}{Option to compute confidence intervals.
0: Nothing is computed.
1: sigmahat is obtain from kappa(hat) and thetahat, and CI is computed.}

\item{niterk}{Number of iterations for the kappa estimation.}

\item{stopiter}{Stopping criterion.}

\item{constr}{Integer value in (-Inf, 0, 1, 2).
Choice of constraint.
-Inf: No constraint.
0:    Positivity contraint.
1:    Monotonicity constraint.
2:    Convexity/concavity constraint.}

\item{sign}{Numeric value in (-1, 1).
1:  Increasing, convexity.
-1: Decreasing, concavity.}

\item{mp}{Numeric value. Number of points to evaluate spline in.}

\item{b}{Numeric nonnegative value, corresponding to truncation window.
If b=0, the non-adapted spline is fitted. This is default.}
}
\examples{
t = generate.t(m = 25); y = generate.y()(t) + generate.noise(t, type = 2)
plot(t, y, col = "blue")
lines(t, L1spline(t, y, 9, lambda = 0.0001))
}

